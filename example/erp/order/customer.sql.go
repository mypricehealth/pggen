// Code generated by pggen. DO NOT EDIT.

package order

import (
	"context"
	"fmt"
	"time"

	pgxdecimal "github.com/jackc/pgx-shopspring-decimal"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

type QueryName struct{}

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	CreateTenant(ctx context.Context, key string, name string) (CreateTenantRow, error)

	FindOrdersByCustomer(ctx context.Context, customerID int32) ([]FindOrdersByCustomerRow, error)

	FindProductsInOrder(ctx context.Context, orderID int32) ([]FindProductsInOrderRow, error)

	InsertCustomer(ctx context.Context, params InsertCustomerParams) (InsertCustomerRow, error)

	InsertOrder(ctx context.Context, params InsertOrderParams) (InsertOrderRow, error)

	FindOrdersByPrice(ctx context.Context, minTotal decimal.Decimal) ([]FindOrdersByPriceRow, error)

	FindOrdersMRR(ctx context.Context) ([]FindOrdersMRRRow, error)

	QueueCreateTenant(batch Batcher, key string, name string) *QueuedCreateTenant

	QueueFindOrdersByCustomer(batch Batcher, customerID int32) *QueuedFindOrdersByCustomer

	QueueFindProductsInOrder(batch Batcher, orderID int32) *QueuedFindProductsInOrder

	QueueInsertCustomer(batch Batcher, params InsertCustomerParams) *QueuedInsertCustomer

	QueueInsertOrder(batch Batcher, params InsertOrderParams) *QueuedInsertOrder

	QueueFindOrdersByPrice(batch Batcher, minTotal decimal.Decimal) *QueuedFindOrdersByPrice

	QueueFindOrdersMRR(batch Batcher) *QueuedFindOrdersMRR
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn    genericConn
	errWrap func(err error) error
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
	TypeMap() *pgtype.Map
	LoadTypes(ctx context.Context, typeNames []string) ([]*pgtype.Type, error)
}

type Batcher interface {
	Queue(query string, arguments ...any) *pgx.QueuedQuery
}

// NewQuerier creates a DBQuerier
func NewQuerier(ctx context.Context, conn genericConn) (*DBQuerier, error) {
	errWrap := func(err error) error {
		return err
	}

	err := registerTypes(context.Background(), conn)
	if err != nil {
		return nil, errWrap(fmt.Errorf("could not register types: %w", err))
	}

	return &DBQuerier{
		conn:    conn,
		errWrap: errWrap,
	}, nil
}

func registerTypes(ctx context.Context, conn genericConn) error {
	typeMap := conn.TypeMap()

	// The work pgxdecimal.Register does involves no queries so it may as well
	// be free.
	pgxdecimal.Register(typeMap)

	// Make sure to only register the necessary types. This is really only
	// important for the frequent path of _no_ registrations necessary which
	// would cause an unnecessary extra roundtrip on every query.
	needsRegistering := make([]string, 0, len(typesToRegister))
	for _, typeName := range typesToRegister {
		_, exists := typeMap.TypeForName(typeName)
		if exists {
			continue
		}

		needsRegistering = append(needsRegistering, typeName)
	}

	if len(needsRegistering) == 0 {
		return nil
	}

	types, err := conn.LoadTypes(ctx, needsRegistering)
	if err != nil {
		return fmt.Errorf("could not register types: %w", err)
	}

	typeMap.RegisterTypes(types)

	return nil
}

var typesToRegister = []string{}

func addTypeToRegister(typ string) struct{} {
	typesToRegister = append(typesToRegister, typ)
	return struct{}{}
}

const createTenantSQL = `INSERT INTO tenant (tenant_id, name)
VALUES (base36_decode($1::text)::tenant_id, $2::text)
RETURNING *;`

type CreateTenantRow struct {
	TenantID int     `json:"tenant_id"`
	Rname    *string `json:"rname"`
	Name     string  `json:"name"`
}

// CreateTenant implements Querier.CreateTenant.
func (q *DBQuerier) CreateTenant(ctx context.Context, key string, name string) (CreateTenantRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "CreateTenant")
	rows, err := q.conn.Query(ctx, createTenantSQL, key, name)
	if err != nil {
		return CreateTenantRow{}, fmt.Errorf("query CreateTenant: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[CreateTenantRow])
	return res, q.errWrap(err)
}

type QueuedCreateTenant struct {
	wrapError func(err error) error
	onResult  func(CreateTenantRow) error
}

func (q *QueuedCreateTenant) WrapError(wrapError func(err error) error) {
	q.wrapError = wrapError
}

func (q *QueuedCreateTenant) OnResult(onResult func(CreateTenantRow) error) {
	q.onResult = onResult
}

func (q *QueuedCreateTenant) runWrapError(err error) error {
	if q.wrapError == nil {
		return err
	}

	return q.wrapError(err)
}

func (q *QueuedCreateTenant) runOnResult(result CreateTenantRow) error {
	if q.onResult == nil {
		return nil
	}

	return q.onResult(result)
}

// QueueCreateTenant implements Querier.QueueCreateTenant.
//
//nolint:contextcheck
func (q *DBQuerier) QueueCreateTenant(batch Batcher, key string, name string) *QueuedCreateTenant {
	queued := &QueuedCreateTenant{}

	queuedQuery := batch.Queue(createTenantSQL, key, name)
	queuedQuery.Fn = func(br pgx.BatchResults) error {
		rows, err := br.Query()
		if err != nil {
			return queued.runWrapError(err)
		}
		res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[CreateTenantRow])
		if err != nil {
			return queued.runWrapError(err)
		}

		return queued.runOnResult(res)
	}

	return queued
}

const findOrdersByCustomerSQL = `SELECT *
FROM orders
WHERE customer_id = $1;`

type FindOrdersByCustomerRow struct {
	OrderID    int32           `json:"order_id"`
	OrderDate  time.Time       `json:"order_date"`
	OrderTotal decimal.Decimal `json:"order_total"`
	CustomerID *int32          `json:"customer_id"`
}

// FindOrdersByCustomer implements Querier.FindOrdersByCustomer.
func (q *DBQuerier) FindOrdersByCustomer(ctx context.Context, customerID int32) ([]FindOrdersByCustomerRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "FindOrdersByCustomer")
	rows, err := q.conn.Query(ctx, findOrdersByCustomerSQL, customerID)
	if err != nil {
		return nil, fmt.Errorf("query FindOrdersByCustomer: %w", q.errWrap(err))
	}
	res, err := pgx.CollectRows(rows, pgx.RowToStructByName[FindOrdersByCustomerRow])
	return res, q.errWrap(err)
}

type QueuedFindOrdersByCustomer struct {
	wrapError func(err error) error
	onResult  func([]FindOrdersByCustomerRow) error
}

func (q *QueuedFindOrdersByCustomer) WrapError(wrapError func(err error) error) {
	q.wrapError = wrapError
}

func (q *QueuedFindOrdersByCustomer) OnResult(onResult func([]FindOrdersByCustomerRow) error) {
	q.onResult = onResult
}

func (q *QueuedFindOrdersByCustomer) runWrapError(err error) error {
	if q.wrapError == nil {
		return err
	}

	return q.wrapError(err)
}

func (q *QueuedFindOrdersByCustomer) runOnResult(result []FindOrdersByCustomerRow) error {
	if q.onResult == nil {
		return nil
	}

	return q.onResult(result)
}

// QueueFindOrdersByCustomer implements Querier.QueueFindOrdersByCustomer.
//
//nolint:contextcheck
func (q *DBQuerier) QueueFindOrdersByCustomer(batch Batcher, customerID int32) *QueuedFindOrdersByCustomer {
	queued := &QueuedFindOrdersByCustomer{}

	queuedQuery := batch.Queue(findOrdersByCustomerSQL, customerID)
	queuedQuery.Fn = func(br pgx.BatchResults) error {
		rows, err := br.Query()
		if err != nil {
			return queued.runWrapError(err)
		}
		res, err := pgx.CollectRows(rows, pgx.RowToStructByName[FindOrdersByCustomerRow])
		if err != nil {
			return queued.runWrapError(err)
		}

		return queued.runOnResult(res)
	}

	return queued
}

const findProductsInOrderSQL = `SELECT o.order_id, p.product_id, p.name
FROM orders o
  INNER JOIN order_product op USING (order_id)
  INNER JOIN product p USING (product_id)
WHERE o.order_id = $1;`

type FindProductsInOrderRow struct {
	OrderID   *int32  `json:"order_id"`
	ProductID *int32  `json:"product_id"`
	Name      *string `json:"name"`
}

// FindProductsInOrder implements Querier.FindProductsInOrder.
func (q *DBQuerier) FindProductsInOrder(ctx context.Context, orderID int32) ([]FindProductsInOrderRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "FindProductsInOrder")
	rows, err := q.conn.Query(ctx, findProductsInOrderSQL, orderID)
	if err != nil {
		return nil, fmt.Errorf("query FindProductsInOrder: %w", q.errWrap(err))
	}
	res, err := pgx.CollectRows(rows, pgx.RowToStructByName[FindProductsInOrderRow])
	return res, q.errWrap(err)
}

type QueuedFindProductsInOrder struct {
	wrapError func(err error) error
	onResult  func([]FindProductsInOrderRow) error
}

func (q *QueuedFindProductsInOrder) WrapError(wrapError func(err error) error) {
	q.wrapError = wrapError
}

func (q *QueuedFindProductsInOrder) OnResult(onResult func([]FindProductsInOrderRow) error) {
	q.onResult = onResult
}

func (q *QueuedFindProductsInOrder) runWrapError(err error) error {
	if q.wrapError == nil {
		return err
	}

	return q.wrapError(err)
}

func (q *QueuedFindProductsInOrder) runOnResult(result []FindProductsInOrderRow) error {
	if q.onResult == nil {
		return nil
	}

	return q.onResult(result)
}

// QueueFindProductsInOrder implements Querier.QueueFindProductsInOrder.
//
//nolint:contextcheck
func (q *DBQuerier) QueueFindProductsInOrder(batch Batcher, orderID int32) *QueuedFindProductsInOrder {
	queued := &QueuedFindProductsInOrder{}

	queuedQuery := batch.Queue(findProductsInOrderSQL, orderID)
	queuedQuery.Fn = func(br pgx.BatchResults) error {
		rows, err := br.Query()
		if err != nil {
			return queued.runWrapError(err)
		}
		res, err := pgx.CollectRows(rows, pgx.RowToStructByName[FindProductsInOrderRow])
		if err != nil {
			return queued.runWrapError(err)
		}

		return queued.runOnResult(res)
	}

	return queued
}

const insertCustomerSQL = `INSERT INTO customer (first_name, last_name, email)
VALUES ($1, $2, $3)
RETURNING *;`

type InsertCustomerParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

type InsertCustomerRow struct {
	CustomerID int32  `json:"customer_id"`
	FirstName  string `json:"first_name"`
	LastName   string `json:"last_name"`
	Email      string `json:"email"`
}

// InsertCustomer implements Querier.InsertCustomer.
func (q *DBQuerier) InsertCustomer(ctx context.Context, params InsertCustomerParams) (InsertCustomerRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "InsertCustomer")
	rows, err := q.conn.Query(ctx, insertCustomerSQL, params.FirstName, params.LastName, params.Email)
	if err != nil {
		return InsertCustomerRow{}, fmt.Errorf("query InsertCustomer: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[InsertCustomerRow])
	return res, q.errWrap(err)
}

type QueuedInsertCustomer struct {
	wrapError func(err error) error
	onResult  func(InsertCustomerRow) error
}

func (q *QueuedInsertCustomer) WrapError(wrapError func(err error) error) {
	q.wrapError = wrapError
}

func (q *QueuedInsertCustomer) OnResult(onResult func(InsertCustomerRow) error) {
	q.onResult = onResult
}

func (q *QueuedInsertCustomer) runWrapError(err error) error {
	if q.wrapError == nil {
		return err
	}

	return q.wrapError(err)
}

func (q *QueuedInsertCustomer) runOnResult(result InsertCustomerRow) error {
	if q.onResult == nil {
		return nil
	}

	return q.onResult(result)
}

// QueueInsertCustomer implements Querier.QueueInsertCustomer.
//
//nolint:contextcheck
func (q *DBQuerier) QueueInsertCustomer(batch Batcher, params InsertCustomerParams) *QueuedInsertCustomer {
	queued := &QueuedInsertCustomer{}

	queuedQuery := batch.Queue(insertCustomerSQL, params.FirstName, params.LastName, params.Email)
	queuedQuery.Fn = func(br pgx.BatchResults) error {
		rows, err := br.Query()
		if err != nil {
			return queued.runWrapError(err)
		}
		res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[InsertCustomerRow])
		if err != nil {
			return queued.runWrapError(err)
		}

		return queued.runOnResult(res)
	}

	return queued
}

const insertOrderSQL = `INSERT INTO orders (order_date, order_total, customer_id)
VALUES ($1, $2, $3)
RETURNING *;`

type InsertOrderParams struct {
	OrderDate  time.Time       `json:"order_date"`
	OrderTotal decimal.Decimal `json:"order_total"`
	CustID     int32           `json:"cust_id"`
}

type InsertOrderRow struct {
	OrderID    int32           `json:"order_id"`
	OrderDate  time.Time       `json:"order_date"`
	OrderTotal decimal.Decimal `json:"order_total"`
	CustomerID *int32          `json:"customer_id"`
}

// InsertOrder implements Querier.InsertOrder.
func (q *DBQuerier) InsertOrder(ctx context.Context, params InsertOrderParams) (InsertOrderRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "InsertOrder")
	rows, err := q.conn.Query(ctx, insertOrderSQL, params.OrderDate, params.OrderTotal, params.CustID)
	if err != nil {
		return InsertOrderRow{}, fmt.Errorf("query InsertOrder: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[InsertOrderRow])
	return res, q.errWrap(err)
}

type QueuedInsertOrder struct {
	wrapError func(err error) error
	onResult  func(InsertOrderRow) error
}

func (q *QueuedInsertOrder) WrapError(wrapError func(err error) error) {
	q.wrapError = wrapError
}

func (q *QueuedInsertOrder) OnResult(onResult func(InsertOrderRow) error) {
	q.onResult = onResult
}

func (q *QueuedInsertOrder) runWrapError(err error) error {
	if q.wrapError == nil {
		return err
	}

	return q.wrapError(err)
}

func (q *QueuedInsertOrder) runOnResult(result InsertOrderRow) error {
	if q.onResult == nil {
		return nil
	}

	return q.onResult(result)
}

// QueueInsertOrder implements Querier.QueueInsertOrder.
//
//nolint:contextcheck
func (q *DBQuerier) QueueInsertOrder(batch Batcher, params InsertOrderParams) *QueuedInsertOrder {
	queued := &QueuedInsertOrder{}

	queuedQuery := batch.Queue(insertOrderSQL, params.OrderDate, params.OrderTotal, params.CustID)
	queuedQuery.Fn = func(br pgx.BatchResults) error {
		rows, err := br.Query()
		if err != nil {
			return queued.runWrapError(err)
		}
		res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[InsertOrderRow])
		if err != nil {
			return queued.runWrapError(err)
		}

		return queued.runOnResult(res)
	}

	return queued
}
