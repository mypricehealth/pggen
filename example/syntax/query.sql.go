// Code generated by pggen. DO NOT EDIT.

package syntax

import (
	"context"
	"fmt"
	"sync"

	pgxdecimal "github.com/jackc/pgx-shopspring-decimal"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

type QueryName struct{}

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	// Query to test escaping in generated Go.
	Backtick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickQuoteBacktick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickNewline(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickDoubleQuote(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickBackslashN(ctx context.Context) (string, error)

	// Illegal names.
	IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error)

	// Space after pggen.arg
	SpaceAfter(ctx context.Context, space string) (string, error)

	// Enum named 123.
	BadEnumName(ctx context.Context) (UnnamedEnum123, error)

	GoKeyword(ctx context.Context, go_ string) (string, error)
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn    genericConn
	errWrap func(err error) error
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
	TypeMap() *pgtype.Map
	LoadType(ctx context.Context, typeName string) (*pgtype.Type, error)
}

// NewQuerier creates a DBQuerier that implements Querier.
func NewQuerier(conn genericConn) *DBQuerier {
	return &DBQuerier{
		conn: conn,
		errWrap: func(err error) error {
			return err
		},
	}
}

// UnnamedEnum123 represents the Postgres enum "123".
type UnnamedEnum123 string

const (
	UnnamedEnum123InconvertibleEnumName UnnamedEnum123 = "inconvertible_enum_name"
	UnnamedEnum123UnnamedLabel1         UnnamedEnum123 = ""
	UnnamedEnum123UnnamedLabel2111      UnnamedEnum123 = "111"
	UnnamedEnum123UnnamedLabel3         UnnamedEnum123 = "!!"
)

func (u UnnamedEnum123) String() string { return string(u) }

var registerOnce sync.Once
var registerErr error

func registerTypes(ctx context.Context, conn genericConn) error {
	registerOnce.Do(func() {
		typeMap := conn.TypeMap()

		pgxdecimal.Register(typeMap)
		for _, typ := range typesToRegister {
			dt, err := conn.LoadType(ctx, typ)
			if err != nil {
				registerErr = err
				return
			}
			typeMap.RegisterType(dt)
		}
	})

	return registerErr
}

var typesToRegister = []string{}

func addTypeToRegister(typ string) struct{} {
	typesToRegister = append(typesToRegister, typ)
	return struct{}{}
}

const backtickSQL = "SELECT '`';"

// Backtick implements Querier.Backtick.
func (q *DBQuerier) Backtick(ctx context.Context) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "Backtick")
	rows, err := q.conn.Query(ctx, backtickSQL)
	if err != nil {
		return "", fmt.Errorf("query Backtick: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const backtickQuoteBacktickSQL = "SELECT '`\"`';"

// BacktickQuoteBacktick implements Querier.BacktickQuoteBacktick.
func (q *DBQuerier) BacktickQuoteBacktick(ctx context.Context) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "BacktickQuoteBacktick")
	rows, err := q.conn.Query(ctx, backtickQuoteBacktickSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickQuoteBacktick: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const backtickNewlineSQL = "SELECT '`\n';"

// BacktickNewline implements Querier.BacktickNewline.
func (q *DBQuerier) BacktickNewline(ctx context.Context) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "BacktickNewline")
	rows, err := q.conn.Query(ctx, backtickNewlineSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickNewline: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const backtickDoubleQuoteSQL = "SELECT '`\"';"

// BacktickDoubleQuote implements Querier.BacktickDoubleQuote.
func (q *DBQuerier) BacktickDoubleQuote(ctx context.Context) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "BacktickDoubleQuote")
	rows, err := q.conn.Query(ctx, backtickDoubleQuoteSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickDoubleQuote: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const backtickBackslashNSQL = "SELECT '`\\n';"

// BacktickBackslashN implements Querier.BacktickBackslashN.
func (q *DBQuerier) BacktickBackslashN(ctx context.Context) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "BacktickBackslashN")
	rows, err := q.conn.Query(ctx, backtickBackslashNSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickBackslashN: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const illegalNameSymbolsSQL = "SELECT '`\\n' as \"$\", $1 as \"foo.bar!@#$%&*()\"\"--+\";"

type IllegalNameSymbolsRow struct {
	UnnamedColumn0 string `json:"$"`
	FooBar         string `json:"foo.bar!@#$%&*()\"--+"`
}

// IllegalNameSymbols implements Querier.IllegalNameSymbols.
func (q *DBQuerier) IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return IllegalNameSymbolsRow{}, fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "IllegalNameSymbols")
	rows, err := q.conn.Query(ctx, illegalNameSymbolsSQL, helloWorld)
	if err != nil {
		return IllegalNameSymbolsRow{}, fmt.Errorf("query IllegalNameSymbols: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[IllegalNameSymbolsRow])
	return res, q.errWrap(err)
}

const spaceAfterSQL = `SELECT $1;`

// SpaceAfter implements Querier.SpaceAfter.
func (q *DBQuerier) SpaceAfter(ctx context.Context, space string) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "SpaceAfter")
	rows, err := q.conn.Query(ctx, spaceAfterSQL, space)
	if err != nil {
		return "", fmt.Errorf("query SpaceAfter: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}

const badEnumNameSQL = `SELECT 'inconvertible_enum_name'::"123";`

// BadEnumName implements Querier.BadEnumName.
func (q *DBQuerier) BadEnumName(ctx context.Context) (UnnamedEnum123, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return UnnamedEnum123(""), fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "BadEnumName")
	rows, err := q.conn.Query(ctx, badEnumNameSQL)
	if err != nil {
		return UnnamedEnum123(""), fmt.Errorf("query BadEnumName: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[UnnamedEnum123])
	return res, q.errWrap(err)
}

const goKeywordSQL = `SELECT $1::text;`

// GoKeyword implements Querier.GoKeyword.
func (q *DBQuerier) GoKeyword(ctx context.Context, go_ string) (string, error) {
	err := registerTypes(ctx, q.conn)
	if err != nil {
		return "", fmt.Errorf("registering types failed: %w", q.errWrap(err))
	}

	ctx = context.WithValue(ctx, QueryName{}, "GoKeyword")
	rows, err := q.conn.Query(ctx, goKeywordSQL, go_)
	if err != nil {
		return "", fmt.Errorf("query GoKeyword: %w", q.errWrap(err))
	}
	res, err := pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
	return res, q.errWrap(err)
}
