// Code generated by pggen. DO NOT EDIT.

package syntax

import (
	"context"
	"fmt"
	"sync"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

type QueryName struct{}

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	// Query to test escaping in generated Go.
	Backtick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickQuoteBacktick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickNewline(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickDoubleQuote(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickBackslashN(ctx context.Context) (string, error)

	// Illegal names.
	IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error)

	// Space after pggen.arg
	SpaceAfter(ctx context.Context, space string) (string, error)

	// Enum named 123.
	BadEnumName(ctx context.Context) (UnnamedEnum123, error)

	GoKeyword(ctx context.Context, go_ string) (string, error)
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn genericConn
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
}

// NewQuerier creates a DBQuerier that implements Querier.
func NewQuerier(conn genericConn) *DBQuerier {
	return &DBQuerier{conn: conn}
}

// UnnamedEnum123 represents the Postgres enum "123".
type UnnamedEnum123 string

const (
	UnnamedEnum123InconvertibleEnumName UnnamedEnum123 = "inconvertible_enum_name"
	UnnamedEnum123UnnamedLabel1         UnnamedEnum123 = ""
	UnnamedEnum123UnnamedLabel2111      UnnamedEnum123 = "111"
	UnnamedEnum123UnnamedLabel3         UnnamedEnum123 = "!!"
)

func (u UnnamedEnum123) String() string { return string(u) }

const backtickSQL = "SELECT '`';"

// Backtick implements Querier.Backtick.
func (q *DBQuerier) Backtick(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "Backtick")
	rows, err := q.conn.Query(ctx, backtickSQL)
	if err != nil {
		return "", fmt.Errorf("query Backtick: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const backtickQuoteBacktickSQL = "SELECT '`\"`';"

// BacktickQuoteBacktick implements Querier.BacktickQuoteBacktick.
func (q *DBQuerier) BacktickQuoteBacktick(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "BacktickQuoteBacktick")
	rows, err := q.conn.Query(ctx, backtickQuoteBacktickSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickQuoteBacktick: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const backtickNewlineSQL = "SELECT '`\n';"

// BacktickNewline implements Querier.BacktickNewline.
func (q *DBQuerier) BacktickNewline(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "BacktickNewline")
	rows, err := q.conn.Query(ctx, backtickNewlineSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickNewline: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const backtickDoubleQuoteSQL = "SELECT '`\"';"

// BacktickDoubleQuote implements Querier.BacktickDoubleQuote.
func (q *DBQuerier) BacktickDoubleQuote(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "BacktickDoubleQuote")
	rows, err := q.conn.Query(ctx, backtickDoubleQuoteSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickDoubleQuote: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const backtickBackslashNSQL = "SELECT '`\\n';"

// BacktickBackslashN implements Querier.BacktickBackslashN.
func (q *DBQuerier) BacktickBackslashN(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "BacktickBackslashN")
	rows, err := q.conn.Query(ctx, backtickBackslashNSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickBackslashN: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const illegalNameSymbolsSQL = "SELECT '`\\n' as \"$\", $1 as \"foo.bar!@#$%&*()\"\"--+\";"

type IllegalNameSymbolsRow struct {
	UnnamedColumn0 string `json:"$"`
	FooBar         string `json:"foo.bar!@#$%&*()\"--+"`
}

// IllegalNameSymbols implements Querier.IllegalNameSymbols.
func (q *DBQuerier) IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error) {
	ctx = context.WithValue(ctx, QueryName{}, "IllegalNameSymbols")
	rows, err := q.conn.Query(ctx, illegalNameSymbolsSQL, helloWorld)
	if err != nil {
		return IllegalNameSymbolsRow{}, fmt.Errorf("query IllegalNameSymbols: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowToStructByName[IllegalNameSymbolsRow])
}

const spaceAfterSQL = `SELECT $1;`

// SpaceAfter implements Querier.SpaceAfter.
func (q *DBQuerier) SpaceAfter(ctx context.Context, space string) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "SpaceAfter")
	rows, err := q.conn.Query(ctx, spaceAfterSQL, space)
	if err != nil {
		return "", fmt.Errorf("query SpaceAfter: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

const badEnumNameSQL = `SELECT 'inconvertible_enum_name'::"123";`

// BadEnumName implements Querier.BadEnumName.
func (q *DBQuerier) BadEnumName(ctx context.Context) (UnnamedEnum123, error) {
	ctx = context.WithValue(ctx, QueryName{}, "BadEnumName")
	rows, err := q.conn.Query(ctx, badEnumNameSQL)
	if err != nil {
		return UnnamedEnum123{}, fmt.Errorf("query BadEnumName: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[UnnamedEnum123])
}

const goKeywordSQL = `SELECT $1::text;`

// GoKeyword implements Querier.GoKeyword.
func (q *DBQuerier) GoKeyword(ctx context.Context, go_ string) (string, error) {
	ctx = context.WithValue(ctx, QueryName{}, "GoKeyword")
	rows, err := q.conn.Query(ctx, goKeywordSQL, go_)
	if err != nil {
		return "", fmt.Errorf("query GoKeyword: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, pgx.RowTo[string])
}

type scanCacheKey struct {
	oid      uint32
	format   int16
	typeName string
}

var (
	plans   = make(map[scanCacheKey]pgtype.ScanPlan, 16)
	plansMu sync.RWMutex
)

func planScan(codec pgtype.Codec, fd pgconn.FieldDescription, target any) pgtype.ScanPlan {
	key := scanCacheKey{fd.DataTypeOID, fd.Format, fmt.Sprintf("%T", target)}
	plansMu.RLock()
	plan := plans[key]
	plansMu.RUnlock()
	if plan != nil {
		return plan
	}
	plan = codec.PlanScan(nil, fd.DataTypeOID, fd.Format, target)
	plansMu.Lock()
	plans[key] = plan
	plansMu.Unlock()
	return plan
}

type ptrScanner[T any] struct {
	basePlan pgtype.ScanPlan
}

func (s ptrScanner[T]) Scan(src []byte, dst any) error {
	if src == nil {
		return nil
	}
	d := dst.(**T)
	*d = new(T)
	return s.basePlan.Scan(src, *d)
}

func planPtrScan[T any](codec pgtype.Codec, fd pgconn.FieldDescription, target *T) pgtype.ScanPlan {
	key := scanCacheKey{fd.DataTypeOID, fd.Format, fmt.Sprintf("*%T", target)}
	plansMu.RLock()
	plan := plans[key]
	plansMu.RUnlock()
	if plan != nil {
		return plan
	}
	basePlan := planScan(codec, fd, target)
	ptrPlan := ptrScanner[T]{basePlan}
	plansMu.Lock()
	plans[key] = plan
	plansMu.Unlock()
	return ptrPlan
}
